// KotobaTranscriber -- Tauri main entry point
// Python sidecar (kotoba_backend) lifecycle management, system tray, IPC commands

#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod commands;
mod tray;

use log::{error, info, warn};
use std::sync::Mutex;
use tauri::Manager;

/// Application state shared across threads
pub struct AppState {
    /// Python backend API port number
    pub api_port: Mutex<Option<u16>>,
    /// API authentication token (generated by Python backend)
    pub api_token: Mutex<Option<String>>,
    /// Sidecar process child handle
    pub sidecar_child: Mutex<Option<tauri_plugin_shell::process::CommandChild>>,
}

impl AppState {
    /// Safely read the API port (handles poisoned mutex)
    pub fn get_port(&self) -> Option<u16> {
        match self.api_port.lock() {
            Ok(guard) => *guard,
            Err(poisoned) => {
                warn!("api_port mutex was poisoned, recovering");
                *poisoned.into_inner()
            }
        }
    }

    /// Safely set the API port (handles poisoned mutex)
    pub fn set_port(&self, port: u16) {
        match self.api_port.lock() {
            Ok(mut guard) => *guard = Some(port),
            Err(poisoned) => {
                warn!("api_port mutex was poisoned, recovering");
                *poisoned.into_inner() = Some(port);
            }
        }
    }

    /// Safely read the API token (handles poisoned mutex)
    pub fn get_token(&self) -> Option<String> {
        match self.api_token.lock() {
            Ok(guard) => guard.clone(),
            Err(poisoned) => {
                warn!("api_token mutex was poisoned, recovering");
                poisoned.into_inner().clone()
            }
        }
    }

    /// Safely set the API token (handles poisoned mutex)
    pub fn set_token(&self, token: String) {
        match self.api_token.lock() {
            Ok(mut guard) => *guard = Some(token),
            Err(poisoned) => {
                warn!("api_token mutex was poisoned, recovering");
                *poisoned.into_inner() = Some(token);
            }
        }
    }

    /// Safely take the sidecar child handle for cleanup (handles poisoned mutex)
    pub fn take_sidecar(&self) -> Option<tauri_plugin_shell::process::CommandChild> {
        match self.sidecar_child.lock() {
            Ok(mut guard) => guard.take(),
            Err(poisoned) => {
                warn!("sidecar_child mutex was poisoned, recovering");
                poisoned.into_inner().take()
            }
        }
    }

    /// Safely store the sidecar child handle (handles poisoned mutex)
    pub fn set_sidecar(&self, child: tauri_plugin_shell::process::CommandChild) {
        match self.sidecar_child.lock() {
            Ok(mut guard) => *guard = Some(child),
            Err(poisoned) => {
                warn!("sidecar_child mutex was poisoned, recovering");
                *poisoned.into_inner() = Some(child);
            }
        }
    }
}

/// Gracefully shut down the sidecar, falling back to kill after timeout
fn shutdown_sidecar(state: &AppState) {
    let port = state.get_port();
    let token = state.get_token();

    // Step 1: Try graceful shutdown via HTTP POST /api/shutdown
    if let Some(p) = port {
        info!("Requesting graceful shutdown of Python backend (port {})...", p);
        let token_header = match &token {
            Some(t) => format!("Authorization: Bearer {}\r\n", t),
            None => String::new(),
        };
        // Fire-and-forget HTTP request with short timeout
        let _ = std::thread::spawn(move || {
            // Use a minimal blocking HTTP client (ureq-like approach via std::net)
            if let Ok(mut stream) =
                std::net::TcpStream::connect_timeout(
                    &format!("127.0.0.1:{}", p).parse().unwrap(),
                    std::time::Duration::from_secs(2),
                )
            {
                use std::io::Write;
                let request = format!(
                    "POST /api/shutdown HTTP/1.1\r\nHost: 127.0.0.1:{}\r\n{}Content-Length: 0\r\nConnection: close\r\n\r\n",
                    p, token_header
                );
                let _ = stream.write_all(request.as_bytes());
                let _ = stream.flush();
            }
        })
        .join();

        // Give the backend time to shut down gracefully
        std::thread::sleep(std::time::Duration::from_secs(3));
    }

    // Step 2: Force kill if still running
    if let Some(child) = state.take_sidecar() {
        info!("Force-stopping Python backend...");
        if let Err(e) = child.kill() {
            error!("Failed to kill sidecar process: {}", e);
        }
    }
}

fn main() {
    let _ = env_logger::try_init();

    tauri::Builder::default()
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_notification::init())
        .plugin(tauri_plugin_autostart::init(
            tauri_plugin_autostart::MacosLauncher::LaunchAgent,
            None,
        ))
        .plugin(tauri_plugin_single_instance::init(|app, _args, _cwd| {
            // If an instance already exists, bring the window to the front
            if let Some(window) = app.get_webview_window("main") {
                let _ = window.show();
                let _ = window.unminimize();
                let _ = window.set_focus();
            }
        }))
        .plugin(tauri_plugin_shell::init())
        .manage(AppState {
            api_port: Mutex::new(None),
            api_token: Mutex::new(None),
            sidecar_child: Mutex::new(None),
        })
        .invoke_handler(tauri::generate_handler![
            commands::get_api_port,
            commands::get_api_token,
            commands::select_file,
            commands::select_files,
            commands::select_folder,
        ])
        .setup(|app| {
            info!("KotobaTranscriber starting...");

            // Initialize system tray
            tray::create_tray(app)?;

            // Start Python sidecar
            let app_handle = app.handle().clone();
            tauri::async_runtime::spawn(async move {
                match start_sidecar(&app_handle).await {
                    Ok((port, token)) => {
                        info!("Python backend started on port {}", port);
                        let state = app_handle.state::<AppState>();
                        state.set_port(port);
                        state.set_token(token.clone());

                        // Notify the frontend that the backend is ready (port + token)
                        if let Some(window) = app_handle.get_webview_window("main") {
                            let payload = serde_json::json!({"port": port, "token": token});
                            let _ = window.emit("backend-ready", payload);
                        }
                    }
                    Err(e) => {
                        error!("Failed to start Python backend: {}", e);
                        // Notify the frontend about the failure
                        if let Some(window) = app_handle.get_webview_window("main") {
                            let _ = window.emit("backend-error", e.to_string());
                        }
                    }
                }
            });

            Ok(())
        })
        .on_window_event(|window, event| {
            // Close button -> minimize to tray instead of exiting
            if let tauri::WindowEvent::CloseRequested { api, .. } = event {
                let _ = window.hide();
                api.prevent_close();
            }
        })
        .build(tauri::generate_context!())
        .expect("error while building tauri application")
        .run(|app_handle, event| {
            match event {
                tauri::RunEvent::ExitRequested { .. } => {
                    // Kill sidecar before the process exits
                    let state = app_handle.state::<AppState>();
                    shutdown_sidecar(state.inner());
                }
                tauri::RunEvent::Exit => {
                    // Final cleanup â€” ensure sidecar is dead even if ExitRequested was skipped
                    let state = app_handle.state::<AppState>();
                    shutdown_sidecar(state.inner());
                }
                _ => {}
            }
        });
}

/// Start the Python sidecar and read the API port + token from its stdout.
///
/// The sidecar is expected to print a JSON line `{"port": <number>, "token": "<string>"}` to stdout
/// within 30 seconds of startup.
async fn start_sidecar(app: &tauri::AppHandle) -> Result<(u16, String), Box<dyn std::error::Error>> {
    use tauri_plugin_shell::ShellExt;

    let command = app
        .shell()
        .sidecar("kotoba_backend")
        .map_err(|e| format!("Failed to create sidecar command: {}", e))?;

    let (mut rx, child) = command
        .spawn()
        .map_err(|e| format!("Failed to spawn sidecar process: {}", e))?;

    // Read the port number and token from stdout with a timeout
    let result: Result<
        Result<(u16, String), Box<dyn std::error::Error>>,
        tokio::time::error::Elapsed,
    > = tokio::time::timeout(std::time::Duration::from_secs(30), async {
        while let Some(event) = rx.recv().await {
            match event {
                tauri_plugin_shell::process::CommandEvent::Stdout(line) => {
                    let line_str = String::from_utf8_lossy(&line);
                    let trimmed = line_str.trim();
                    if trimmed.is_empty() {
                        continue;
                    }

                    // Try to parse as JSON with "port" and "token" fields
                    if let Ok(json) = serde_json::from_str::<serde_json::Value>(trimmed) {
                        if let Some(port_value) = json.get("port").and_then(|v| v.as_u64()) {
                            // Validate port range (1..=65535)
                            if port_value == 0 || port_value > 65535 {
                                return Err(format!(
                                    "Sidecar reported invalid port: {}",
                                    port_value
                                )
                                .into());
                            }
                            let token = json.get("token")
                                .and_then(|v| v.as_str())
                                .unwrap_or("")
                                .to_string();
                            return Ok((port_value as u16, token));
                        }
                    }
                    // Non-JSON stdout lines are informational, log them
                    info!("[sidecar stdout] {}", trimmed);
                }
                tauri_plugin_shell::process::CommandEvent::Stderr(line) => {
                    let line_str = String::from_utf8_lossy(&line);
                    let trimmed = line_str.trim();
                    if !trimmed.is_empty() {
                        warn!("[sidecar stderr] {}", trimmed);
                    }
                }
                tauri_plugin_shell::process::CommandEvent::Terminated(status) => {
                    return Err(format!(
                        "Sidecar terminated unexpectedly with status: {:?}",
                        status
                    )
                    .into());
                }
                _ => {}
            }
        }
        Err("Sidecar stdout/stderr channel closed without providing port information".into())
    })
    .await;

    match result {
        Ok(Ok((port, token))) => {
            // Success: store the sidecar child handle for later cleanup
            let state = app.state::<AppState>();
            state.set_sidecar(child);
            Ok((port, token))
        }
        Ok(Err(e)) => {
            // Inner error (sidecar crashed or sent bad data) -- kill it
            let _ = child.kill();
            Err(e)
        }
        Err(_elapsed) => {
            // Timeout: kill the orphan sidecar process
            error!("Timeout (30s) waiting for sidecar to report its port");
            let _ = child.kill();
            Err("Timeout (30s) waiting for sidecar to report its port".into())
        }
    }
}

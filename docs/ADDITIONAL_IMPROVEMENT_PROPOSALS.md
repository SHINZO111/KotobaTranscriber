# KotobaTranscriber è¿½åŠ æ”¹å–„ææ¡ˆæ›¸

**ä½œæˆæ—¥**: 2025-10-16
**ç¾åœ¨ã®å“è³ªã‚¹ã‚³ã‚¢**: 9.0/10
**åˆ†æå¯¾è±¡**: å…¨16ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆç´„4,800è¡Œï¼‰

---

## ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

KotobaTranscriberã¯æ—¢ã«é«˜å“è³ªãªã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ï¼ˆ9.0/10ï¼‰ã‚’æŒã£ã¦ã„ã¾ã™ãŒã€ã•ã‚‰ãªã‚‹æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚Šã¾ã™ã€‚æœ¬ãƒ¬ãƒãƒ¼ãƒˆã§ã¯ã€ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡å‰Šæ¸›ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€ä¿å®ˆæ€§å‘ä¸Šã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ã€æ‹¡å¼µæ€§æ”¹å–„ã€ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£å‘ä¸Šã€ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸æ‹¡å……ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå……å®Ÿã®8ã¤ã®è¦³ç‚¹ã‹ã‚‰ã€**å„ªå…ˆåº¦åˆ¥ã«27ã®å…·ä½“çš„ãªæ”¹å–„ææ¡ˆ**ã‚’æç¤ºã—ã¾ã™ã€‚

### ä¸»è¦ãªæ”¹å–„é ˜åŸŸ

1. **ã‚³ãƒ¼ãƒ‰é‡è¤‡ã®å‰Šæ¸›** - DRYåŸå‰‡ã®å¾¹åº•ï¼ˆ5ä»¶ï¼‰
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–** - ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å‰Šæ¸›ã¨ãƒãƒƒãƒå‡¦ç†åŠ¹ç‡åŒ–ï¼ˆ4ä»¶ï¼‰
3. **ä¿å®ˆæ€§ã®å‘ä¸Š** - è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è²¬ä»»åˆ†é›¢ã®æ”¹å–„ï¼ˆ6ä»¶ï¼‰
4. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–** - å…¥åŠ›æ¤œè¨¼ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å¼·åŒ–ï¼ˆ3ä»¶ï¼‰
5. **æ‹¡å¼µæ€§ã®æ”¹å–„** - ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨APIæ‹¡å¼µï¼ˆ4ä»¶ï¼‰
6. **ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š** - UX/UIæ”¹å–„ã¨ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ï¼ˆ2ä»¶ï¼‰
7. **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸** - åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã®æ§‹ç¯‰ï¼ˆ2ä»¶ï¼‰
8. **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå……å®Ÿ** - APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ï¼ˆ1ä»¶ï¼‰

---

## 1. ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ï¼ˆDRYåŸå‰‡é•åï¼‰

### ğŸ”´ é«˜å„ªå…ˆåº¦ 1.1: ãƒ¢ãƒ‡ãƒ«ç®¡ç†ã®å…±é€šåŒ–

**å•é¡Œç‚¹**:
- `FasterWhisperEngine`ã€`TransformersWhisperEngine`ã€`StandaloneLLMCorrector`ã§é‡è¤‡ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ãƒ­ãƒ¼ãƒ‰/ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ­ã‚¸ãƒƒã‚¯
- å„ã‚¯ãƒ©ã‚¹ã§åŒæ§˜ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã€CUDAåˆ¶å¾¡ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ãŒé‡è¤‡

**å½±éŸ¿ç¯„å›²**:
- `faster_whisper_engine.py` (lines 119-148, 282-318)
- `faster_whisper_engine.py` (lines 384-415, 458-502)
- `llm_corrector_standalone.py` (lines 57-97, 201-210)

**è§£æ±ºç­–**:
```python
# æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«: src/model_manager.py
from typing import Optional, Generic, TypeVar
from contextlib import contextmanager
import gc
import logging

T = TypeVar('T')

class ModelManager(Generic[T]):
    """æ±ç”¨ãƒ¢ãƒ‡ãƒ«ç®¡ç†åŸºåº•ã‚¯ãƒ©ã‚¹"""

    def __init__(self, model_name: str, device: str = "auto"):
        self.model_name = model_name
        self.device = self._detect_device(device)
        self.model: Optional[T] = None
        self.is_loaded = False
        self._logger = logging.getLogger(self.__class__.__name__)

    def _detect_device(self, device: str) -> str:
        """ãƒ‡ãƒã‚¤ã‚¹è‡ªå‹•æ¤œå‡º"""
        if device == "auto":
            try:
                import torch
                return "cuda" if torch.cuda.is_available() else "cpu"
            except ImportError:
                return "cpu"
        return device

    @contextmanager
    def load_context(self):
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã§ãƒ¢ãƒ‡ãƒ«ã‚’è‡ªå‹•ç®¡ç†"""
        try:
            self.load_model()
            yield self.model
        finally:
            self.unload_model()

    def unload_model(self) -> None:
        """ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆãƒ¡ãƒ¢ãƒªè§£æ”¾ï¼‰"""
        if self.model is not None:
            self._logger.info(f"Unloading {self.model_name}...")
            del self.model
            self.model = None
            self.is_loaded = False

            # ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
            gc.collect()

            # CUDAä½¿ç”¨æ™‚ã¯è¿½åŠ ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            if self.device == "cuda":
                try:
                    import torch
                    if torch.cuda.is_available():
                        torch.cuda.empty_cache()
                        self._logger.info("CUDA cache cleared")
                except ImportError:
                    pass

            self._logger.info("Model unloaded successfully")
```

**ä½¿ç”¨ä¾‹**:
```python
class FasterWhisperEngine(ModelManager[WhisperModel]):
    def load_model(self) -> bool:
        # å€‹åˆ¥ã®ãƒ­ãƒ¼ãƒ‰ãƒ­ã‚¸ãƒƒã‚¯ã®ã¿å®Ÿè£…
        self.model = WhisperModel(self.model_name, ...)
        self.is_loaded = True
        return True
```

**åŠ¹æœ**:
- ã‚³ãƒ¼ãƒ‰é‡è¤‡: ç´„150è¡Œå‰Šæ¸›
- ä¿å®ˆæ€§: ä¸€ç®‡æ‰€ã§ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’ä¿®æ­£ã§ãã‚‹
- ãƒã‚°å‰Šæ¸›: å…±é€šå‡¦ç†ã®ãƒã‚°ã‚’é›†ç´„

**æ¨å®šå·¥æ•°**: 4æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 1.2: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ±ä¸€

**å•é¡Œç‚¹**:
- `RealtimeTranscriber._handle_processing_error()`ã®ã‚¨ãƒ©ãƒ¼å›å¾©ãƒ­ã‚¸ãƒƒã‚¯ãŒä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§å†åˆ©ç”¨ã•ã‚Œã¦ã„ãªã„
- `BatchTranscriptionWorker`ã‚„`FolderMonitor`ã§ã‚‚åŒæ§˜ã®ã‚¨ãƒ©ãƒ¼å›å¾©ãŒå¿…è¦ã ãŒå®Ÿè£…ãŒç•°ãªã‚‹

**å½±éŸ¿ç¯„å›²**:
- `realtime_transcriber.py` (lines 153-201)
- `main.py` (lines 126-177) - BatchTranscriptionWorker
- `folder_monitor.py` (lines 156-173)

**è§£æ±ºç­–**:
```python
# src/error_recovery.py
from dataclasses import dataclass
from typing import Optional, Callable
import time

@dataclass
class ErrorRecoveryPolicy:
    """ã‚¨ãƒ©ãƒ¼å›å¾©ãƒãƒªã‚·ãƒ¼"""
    max_consecutive_errors: int = 5
    cooldown_time: float = 2.0
    exponential_backoff: bool = False
    on_recovery: Optional[Callable] = None
    on_failure: Optional[Callable] = None

class ErrorRecoveryManager:
    """ã‚¨ãƒ©ãƒ¼å›å¾©ãƒãƒãƒ¼ã‚¸ãƒ£ï¼ˆå†åˆ©ç”¨å¯èƒ½ï¼‰"""

    def __init__(self, policy: ErrorRecoveryPolicy):
        self.policy = policy
        self._consecutive_errors = 0
        self._last_error_time = 0.0
        self._lock = threading.Lock()

    def handle_error(self, error: Exception) -> bool:
        """
        ã‚¨ãƒ©ãƒ¼ã‚’ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã—ã€ç¶™ç¶šå¯èƒ½ã‹ã‚’åˆ¤å®š

        Returns:
            bool: å‡¦ç†ã‚’ç¶™ç¶šã™ã¹ãã‹ã©ã†ã‹
        """
        with self._lock:
            self._consecutive_errors += 1
            self._last_error_time = time.time()

            if self._consecutive_errors >= self.policy.max_consecutive_errors:
                if self.policy.on_failure:
                    self.policy.on_failure(error)
                return False  # å‡¦ç†åœæ­¢

            # ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
            cooldown = self._calculate_cooldown()
            time.sleep(cooldown)

            return True  # å‡¦ç†ç¶™ç¶š

    def _calculate_cooldown(self) -> float:
        """æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã‚’è€ƒæ…®ã—ãŸã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ã‚’è¨ˆç®—"""
        if self.policy.exponential_backoff:
            return self.policy.cooldown_time * (2 ** (self._consecutive_errors - 1))
        return self.policy.cooldown_time

    def reset(self) -> None:
        """ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ"""
        with self._lock:
            if self._consecutive_errors > 0:
                if self.policy.on_recovery:
                    self.policy.on_recovery()
                self._consecutive_errors = 0
                self._last_error_time = 0.0
```

**åŠ¹æœ**:
- ä¸€è²«ã—ãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- è¨­å®šå¯èƒ½ãªãƒãƒªã‚·ãƒ¼ï¼ˆæŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•å¯¾å¿œï¼‰
- ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š

**æ¨å®šå·¥æ•°**: 3æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 1.3: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®çµ±ä¸€åŸºåº•ã‚¯ãƒ©ã‚¹

**å•é¡Œç‚¹**:
- `RealtimeAudioCapture`ã€`FasterWhisperEngine`ã€`TransformersWhisperEngine`ã§`__enter__`/`__exit__`ãŒé‡è¤‡

**å½±éŸ¿ç¯„å›²**:
- `realtime_audio_capture.py` (lines 82-114)
- `faster_whisper_engine.py` (lines 86-117, 351-382)

**è§£æ±ºç­–**:
```python
# src/resource_manager.py
from abc import ABC, abstractmethod
from typing import Optional
import logging

class ResourceManager(ABC):
    """ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã®åŸºåº•ã‚¯ãƒ©ã‚¹ï¼ˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£å¯¾å¿œï¼‰"""

    def __init__(self):
        self._logger = logging.getLogger(self.__class__.__name__)

    def __enter__(self):
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ"""
        self._logger.info(f"Entering {self.__class__.__name__} context")
        try:
            self._initialize_resources()
            return self
        except Exception as e:
            self._logger.error(f"Failed to initialize resources: {e}")
            raise

    def __exit__(self, exc_type: Optional[type], exc_val: Optional[Exception], exc_tb) -> bool:
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ã‚¨ã‚°ã‚¸ãƒƒãƒˆãƒã‚¤ãƒ³ãƒˆ"""
        self._logger.info(f"Exiting {self.__class__.__name__} context")
        try:
            self._cleanup_resources()
        except Exception as e:
            self._logger.error(f"Error during cleanup: {e}")

        # ä¾‹å¤–ã‚’ãƒ­ã‚°ã«è¨˜éŒ²
        if exc_type is not None:
            self._logger.error(f"Exception in context: {exc_type.__name__}: {exc_val}")

        return False  # ä¾‹å¤–ã‚’å†é€å‡º

    @abstractmethod
    def _initialize_resources(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹åˆæœŸåŒ–ï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰"""
        pass

    @abstractmethod
    def _cleanup_resources(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰"""
        pass
```

**ä½¿ç”¨ä¾‹**:
```python
class RealtimeAudioCapture(ResourceManager):
    def _initialize_resources(self) -> None:
        if self.audio is None:
            self.audio = pyaudio.PyAudio()

    def _cleanup_resources(self) -> None:
        self.cleanup()
```

**åŠ¹æœ**:
- ã‚³ãƒ¼ãƒ‰é‡è¤‡: ç´„80è¡Œå‰Šæ¸›
- çµ±ä¸€ã•ã‚ŒãŸãƒ­ã‚°å‡ºåŠ›
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ä¸€è²«æ€§

**æ¨å®šå·¥æ•°**: 2æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 1.4: ãƒ†ã‚­ã‚¹ãƒˆæ•´å½¢ãƒ­ã‚¸ãƒƒã‚¯ã®å…±é€šåŒ–

**å•é¡Œç‚¹**:
- `TextFormatter.add_punctuation()`ã¨`SimpleLLMCorrector._add_intelligent_punctuation()`ã§å¥èª­ç‚¹å‡¦ç†ãŒé‡è¤‡
- æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¤‡æ•°ç®‡æ‰€ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹

**å½±éŸ¿ç¯„å›²**:
- `text_formatter.py` (lines 61-86)
- `llm_corrector_standalone.py` (lines 271-365)

**è§£æ±ºç­–**:
æ–°ã—ã„`PunctuationEngine`ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã€ä¸¡è€…ã§å…±æœ‰ã™ã‚‹ã€‚

**åŠ¹æœ**:
- ã‚³ãƒ¼ãƒ‰é‡è¤‡: ç´„100è¡Œå‰Šæ¸›
- ä¸€è²«ã—ãŸå¥èª­ç‚¹å‡¦ç†

**æ¨å®šå·¥æ•°**: 3æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 1.5: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¤œè¨¼ã®å…±é€šåŒ–

**å•é¡Œç‚¹**:
- `main.py`ã¨`FolderMonitor`ã§éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã®ãƒã‚§ãƒƒã‚¯ãŒé‡è¤‡

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 554-558, 750-754)
- `folder_monitor.py` (lines 24-28, 71-74)

**è§£æ±ºç­–**:
```python
# src/file_utils.py
class AudioFileValidator:
    """éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£"""

    AUDIO_EXTENSIONS = {
        '.mp3', '.wav', '.m4a', '.flac', '.ogg', '.aac',
        '.wma', '.opus', '.amr'
    }

    VIDEO_EXTENSIONS = {
        '.mp4', '.avi', '.mov', '.mkv', '.3gp', '.webm'
    }

    ALL_EXTENSIONS = AUDIO_EXTENSIONS | VIDEO_EXTENSIONS

    @classmethod
    def is_supported(cls, file_path: str) -> bool:
        """ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹"""
        ext = os.path.splitext(file_path)[1].lower()
        return ext in cls.ALL_EXTENSIONS

    @classmethod
    def get_file_filter(cls) -> str:
        """PyQt5ç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ•ã‚£ãƒ«ã‚¿æ–‡å­—åˆ—ã‚’å–å¾—"""
        exts = ' '.join(f'*{ext}' for ext in cls.ALL_EXTENSIONS)
        return f"Audio/Video Files ({exts});;All Files (*)"
```

**åŠ¹æœ**:
- ä¸€ç®‡æ‰€ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆç®¡ç†
- æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè¿½åŠ ãŒå®¹æ˜“

**æ¨å®šå·¥æ•°**: 1æ™‚é–“

---

## 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### ğŸ”´ é«˜å„ªå…ˆåº¦ 2.1: ãƒãƒƒãƒå‡¦ç†ã®ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–

**å•é¡Œç‚¹**:
- `BatchTranscriptionWorker`ã§å„ã‚¹ãƒ¬ãƒƒãƒ‰ãŒç‹¬ç«‹ã—ã¦Whisperãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ã‚‹
- 3ä¸¦åˆ—å‡¦ç†æ™‚ã«3ã¤ã®ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒãƒ¡ãƒ¢ãƒªã«åŒæ™‚å­˜åœ¨ï¼ˆ6-12GBï¼‰

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 104-216) - BatchTranscriptionWorker

**è§£æ±ºç­–**:
```python
# ãƒ¢ãƒ‡ãƒ«ãƒ—ãƒ¼ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å°å…¥
class TranscriptionEnginePool:
    """æ–‡å­—èµ·ã“ã—ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ—ãƒ¼ãƒ«ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ï¼‰"""

    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize()
        return cls._instance

    def _initialize(self):
        self._engine = None
        self._usage_lock = threading.Semaphore(1)  # 1ã¤ã®ãƒ¢ãƒ‡ãƒ«ã‚’é †ç•ªã«ä½¿ç”¨

    def acquire_engine(self) -> TranscriptionEngine:
        """ã‚¨ãƒ³ã‚¸ãƒ³ã‚’å–å¾—ï¼ˆæ’ä»–åˆ¶å¾¡ï¼‰"""
        self._usage_lock.acquire()
        if self._engine is None:
            self._engine = TranscriptionEngine()
            self._engine.load_model()
        return self._engine

    def release_engine(self):
        """ã‚¨ãƒ³ã‚¸ãƒ³ã‚’è§£æ”¾"""
        self._usage_lock.release()

# BatchTranscriptionWorkerã§ä½¿ç”¨
def process_single_file(self, audio_path: str):
    pool = TranscriptionEnginePool()
    engine = pool.acquire_engine()
    try:
        result = engine.transcribe(audio_path)
        # ... å‡¦ç† ...
    finally:
        pool.release_engine()
```

**åŠ¹æœ**:
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: 6-12GB â†’ 2-4GBï¼ˆ50-67%å‰Šæ¸›ï¼‰
- ãƒãƒƒãƒå‡¦ç†é€Ÿåº¦: è‹¥å¹²ä½ä¸‹ã™ã‚‹ãŒã€OOMå›é¿ã§å®‰å®šæ€§å‘ä¸Š

**æ¨å®šå·¥æ•°**: 4æ™‚é–“

---

### ğŸ”´ é«˜å„ªå…ˆåº¦ 2.2: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—ã®ãƒãƒƒãƒ•ã‚¡æœ€é©åŒ–

**å•é¡Œç‚¹**:
- `RealtimeAudioCapture`ã§dequeã®maxlenãŒå›ºå®šã§ã€ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ãªã„
- 50%ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã®ãƒãƒƒãƒ•ã‚¡ç®¡ç†ãŒéåŠ¹ç‡ï¼ˆline 248-253ï¼‰

**å½±éŸ¿ç¯„å›²**:
- `realtime_audio_capture.py` (lines 62-64, 213-260)

**è§£æ±ºç­–**:
```python
class RealtimeAudioCapture:
    def __init__(self, ..., buffer_strategy: str = "ring"):
        # ...
        if buffer_strategy == "ring":
            # ãƒªãƒ³ã‚°ãƒãƒƒãƒ•ã‚¡ï¼ˆå›ºå®šã‚µã‚¤ã‚ºã€é«˜é€Ÿï¼‰
            self.audio_buffer = deque(maxlen=max_buffer_size)
        elif buffer_strategy == "adaptive":
            # é©å¿œçš„ãƒãƒƒãƒ•ã‚¡ï¼ˆã‚µã‚¤ã‚ºå¯å¤‰ï¼‰
            self.audio_buffer = []
            self.max_buffer_size = max_buffer_size

    def _capture_loop(self) -> None:
        # ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã‚’ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ã§åŠ¹ç‡åŒ–
        chunk_size_bytes = chunk_size_samples * 2

        while not self.stop_event.is_set():
            with self._buffer_lock:
                if len(self.audio_buffer) >= chunk_size_bytes:
                    # memoryviewã‚’ä½¿ç”¨ã—ã¦ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼
                    chunk_bytes = memoryview(bytes(self.audio_buffer[:chunk_size_bytes]))

                    # NumPyé…åˆ—ã«å¤‰æ›ï¼ˆã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ï¼‰
                    audio_array = np.frombuffer(chunk_bytes, dtype=np.int16)
                    audio_float = audio_array.astype(np.float32) / 32768.0

                    # å‡¦ç†ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆ50%ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ï¼‰
                    overlap_bytes = chunk_size_bytes // 2
                    for _ in range(overlap_bytes):
                        if self.audio_buffer:
                            self.audio_buffer.popleft()

            # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œï¼ˆãƒ­ãƒƒã‚¯ã®å¤–ï¼‰
            if self.on_audio_chunk:
                self.on_audio_chunk(audio_float)

            time.sleep(0.05)  # 100ms â†’ 50msã«çŸ­ç¸®
```

**åŠ¹æœ**:
- ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼: ç´„50%å‰Šæ¸›
- ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·: 100ms â†’ 50msï¼ˆ50%æ”¹å–„ï¼‰

**æ¨å®šå·¥æ•°**: 3æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 2.3: è©±è€…åˆ†é›¢ã®ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°

**å•é¡Œç‚¹**:
- `FreeSpeakerDiarizer`ã§åŒã˜éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦é‡è¤‡å®Ÿè¡Œã•ã‚Œã‚‹å¯èƒ½æ€§
- åŸ‹ã‚è¾¼ã¿è¨ˆç®—ãŒé‡ã„ï¼ˆ3ç§’ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã”ã¨ï¼‰

**å½±éŸ¿ç¯„å›²**:
- `speaker_diarization_free.py` (lines 96-121, 123-200)

**è§£æ±ºç­–**:
```python
from functools import lru_cache
import hashlib

class FreeSpeakerDiarizer:
    def __init__(self, ..., enable_cache: bool = True):
        self.enable_cache = enable_cache
        self._cache = {}  # {file_hash: segments}

    def diarize(self, audio_path: str, num_speakers: Optional[int] = None) -> List[Dict]:
        if not self.enable_cache:
            return self._diarize_impl(audio_path, num_speakers)

        # ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—
        file_hash = self._compute_file_hash(audio_path)
        cache_key = (file_hash, num_speakers)

        if cache_key in self._cache:
            logger.info(f"Using cached diarization for {audio_path}")
            return self._cache[cache_key]

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒŸã‚¹ - å®Ÿè¡Œã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        result = self._diarize_impl(audio_path, num_speakers)
        self._cache[cache_key] = result
        return result

    def _compute_file_hash(self, file_path: str) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ï¼ˆé«˜é€Ÿï¼‰"""
        with open(file_path, 'rb') as f:
            # æœ€åˆã®1MBã®ã¿ãƒãƒƒã‚·ãƒ¥åŒ–ï¼ˆé«˜é€ŸåŒ–ï¼‰
            return hashlib.md5(f.read(1024 * 1024)).hexdigest()
```

**åŠ¹æœ**:
- é‡è¤‡å‡¦ç†æ™‚é–“: 100% â†’ 0%ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆæ™‚ï¼‰
- ãƒãƒƒãƒå‡¦ç†ã§ã®åŠ¹æœå¤§

**æ¨å®šå·¥æ•°**: 2æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 2.4: VADã®è¨ˆç®—é‡å‰Šæ¸›

**å•é¡Œç‚¹**:
- `AdaptiveVAD`ã§ã‚¨ãƒãƒ«ã‚®ãƒ¼å±¥æ­´ã®ã‚½ãƒ¼ãƒˆãŒæ¯å›å®Ÿè¡Œã•ã‚Œã‚‹ï¼ˆO(n log n)ï¼‰

**å½±éŸ¿ç¯„å›²**:
- `simple_vad.py` (lines 145-170)

**è§£æ±ºç­–**:
```python
class AdaptiveVAD(SimpleVAD):
    def __init__(self, ...):
        super().__init__(...)
        # sorted setã‚’ä½¿ç”¨ã—ã¦ã‚½ãƒ¼ãƒˆæ¸ˆã¿çŠ¶æ…‹ã‚’ç¶­æŒ
        from sortedcontainers import SortedList
        self.energy_history_sorted = SortedList()

    def is_speech_present(self, audio: np.ndarray) -> Tuple[bool, float]:
        energy = self.calculate_energy(audio)

        # ã‚½ãƒ¼ãƒˆæ¸ˆã¿ãƒªã‚¹ãƒˆã«è¿½åŠ ï¼ˆO(log n)ï¼‰
        self.energy_history_sorted.add(energy)

        if len(self.energy_history_sorted) > self.history_size:
            # æœ€å¤ã®è¦ç´ ã‚’å‰Šé™¤
            self.energy_history_sorted.pop(0)

        # ä¸‹ä½25%ã®å¹³å‡ã‚’è¨ˆç®—ï¼ˆã‚½ãƒ¼ãƒˆä¸è¦ï¼‰
        if len(self.energy_history_sorted) >= 10:
            quartile_idx = len(self.energy_history_sorted) // 4
            lower_quartile = self.energy_history_sorted[:quartile_idx]
            estimated_noise = np.mean(lower_quartile)

            # é–¾å€¤æ›´æ–°
            self.noise_level = (
                self.adaptation_rate * estimated_noise +
                (1 - self.adaptation_rate) * self.noise_level
            )
            self.threshold = max(self.noise_level * 2.5, 0.005)

        return super().is_speech_present(audio)
```

**åŠ¹æœ**:
- VADè¨ˆç®—æ™‚é–“: O(n log n) â†’ O(log n)ï¼ˆç´„10å€é«˜é€ŸåŒ–ï¼‰
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§èƒ½å‘ä¸Š

**æ¨å®šå·¥æ•°**: 2æ™‚é–“

---

## 3. ä¿å®ˆæ€§ã®å‘ä¸Š

### ğŸ”´ é«˜å„ªå…ˆåº¦ 3.1: MainWindowã®è²¬ä»»åˆ†é›¢

**å•é¡Œç‚¹**:
- `MainWindow`ãŒ1,600è¡Œè¶…ã§å˜ä¸€è²¬ä»»åŸå‰‡é•å
- UIã€ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã€çŠ¶æ…‹ç®¡ç†ãŒæ··åœ¨

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 293-1610) - MainWindow

**è§£æ±ºç­–**:
```python
# æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ç¾¤
# src/ui/main_window.py - UIå®šç¾©ã®ã¿
# src/ui/file_processing_tab.py - ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¿ãƒ–
# src/ui/realtime_tab.py - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¿ãƒ–
# src/controllers/transcription_controller.py - æ–‡å­—èµ·ã“ã—åˆ¶å¾¡
# src/controllers/folder_monitor_controller.py - ãƒ•ã‚©ãƒ«ãƒ€ç›£è¦–åˆ¶å¾¡
# src/models/application_state.py - ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹

class ApplicationState:
    """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ç®¡ç†ï¼ˆObservable ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰"""
    def __init__(self):
        self.total_processed = 0
        self.total_failed = 0
        self.processing_files = set()
        self._observers = []

    def add_observer(self, observer):
        self._observers.append(observer)

    def notify_observers(self):
        for observer in self._observers:
            observer.update(self)

class TranscriptionController:
    """æ–‡å­—èµ·ã“ã—å‡¦ç†ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©"""
    def __init__(self, state: ApplicationState):
        self.state = state
        self.engine = TranscriptionEngine()
        self.formatter = TextFormatter()

    def transcribe_file(self, file_path: str, options: Dict) -> str:
        # ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®ã¿
        pass

class MainWindow(QMainWindow):
    """ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼ˆUIå®šç¾©ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ã¿ï¼‰"""
    def __init__(self):
        super().__init__()
        self.state = ApplicationState()
        self.transcription_controller = TranscriptionController(self.state)
        self.folder_controller = FolderMonitorController(self.state)
        self.init_ui()
```

**åŠ¹æœ**:
- å¯èª­æ€§: å„ã‚¯ãƒ©ã‚¹200-400è¡Œã«åˆ†å‰²
- ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç‹¬ç«‹ãƒ†ã‚¹ãƒˆå¯èƒ½
- ä¿å®ˆæ€§: å¤‰æ›´ã®å½±éŸ¿ç¯„å›²ãŒæ˜ç¢º

**æ¨å®šå·¥æ•°**: 8æ™‚é–“

---

### ğŸ”´ é«˜å„ªå…ˆåº¦ 3.2: è¨­å®šç®¡ç†ã®çµ±ä¸€

**å•é¡Œç‚¹**:
- è¨­å®šãŒã‚³ãƒ¼ãƒ‰å†…ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ï¼ˆffmpegãƒ‘ã‚¹ã€ãƒ¢ãƒ‡ãƒ«åãªã©ï¼‰
- ç’°å¢ƒå¤‰æ•°ã‚„è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„

**å½±éŸ¿ç¯„å›²**:
- `transcription_engine.py` (line 13) - ffmpegãƒ‘ã‚¹
- `llm_corrector.py` (line 18) - ãƒ¢ãƒ‡ãƒ«å
- `main.py` (lines 805, 1068) - max_workers

**è§£æ±ºç­–**:
```python
# æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«: src/config.py
from dataclasses import dataclass, field
from typing import Optional
import os
import yaml

@dataclass
class TranscriptionConfig:
    """æ–‡å­—èµ·ã“ã—è¨­å®š"""
    model_name: str = "kotoba-tech/kotoba-whisper-v2.2"
    device: str = "auto"
    chunk_length_s: int = 15

@dataclass
class BatchProcessingConfig:
    """ãƒãƒƒãƒå‡¦ç†è¨­å®š"""
    max_workers: int = 3
    enable_diarization: bool = False
    timeout_per_file: int = 3600  # ç§’

@dataclass
class PathConfig:
    """ãƒ‘ã‚¹è¨­å®š"""
    ffmpeg_path: str = r"C:\ffmpeg\ffmpeg-8.0-essentials_build\bin"
    models_dir: str = "models"
    cache_dir: str = ".cache"

@dataclass
class AppConfig:
    """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š"""
    transcription: TranscriptionConfig = field(default_factory=TranscriptionConfig)
    batch_processing: BatchProcessingConfig = field(default_factory=BatchProcessingConfig)
    paths: PathConfig = field(default_factory=PathConfig)

    @classmethod
    def load(cls, config_path: str = "config.yaml") -> 'AppConfig':
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿"""
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
                return cls(**data)
        return cls()

    def save(self, config_path: str = "config.yaml"):
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        from dataclasses import asdict
        with open(config_path, 'w', encoding='utf-8') as f:
            yaml.dump(asdict(self), f, allow_unicode=True)
```

**config.yaml ã®ä¾‹**:
```yaml
transcription:
  model_name: "kotoba-tech/kotoba-whisper-v2.2"
  device: "auto"
  chunk_length_s: 15

batch_processing:
  max_workers: 3
  enable_diarization: false
  timeout_per_file: 3600

paths:
  ffmpeg_path: "C:\\ffmpeg\\ffmpeg-8.0-essentials_build\\bin"
  models_dir: "models"
  cache_dir: ".cache"
```

**åŠ¹æœ**:
- è¨­å®šã®å¯è¦–æ€§å‘ä¸Š
- ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã®è¨­å®šå¤‰æ›´ãŒå®¹æ˜“
- ç’°å¢ƒã”ã¨ã®è¨­å®šåˆ†é›¢ãŒå¯èƒ½

**æ¨å®šå·¥æ•°**: 4æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 3.3: ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ‹¡å¼µ

**å•é¡Œç‚¹**:
- `RealtimeTranscriberFactory`ã®ã¿ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨
- ä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆè©±è€…åˆ†é›¢ã€LLMè£œæ­£ãªã©ï¼‰ã§ã‚‚é©ç”¨ã™ã¹ã

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 40-101) - RealtimeTranscriberFactory

**è§£æ±ºç­–**:
```python
# src/factories.py
from abc import ABC, abstractmethod

class ComponentFactory(ABC):
    """ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ•ã‚¡ã‚¯ãƒˆãƒªã®åŸºåº•ã‚¯ãƒ©ã‚¹"""

    @abstractmethod
    def create(self, **kwargs):
        """ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½œæˆ"""
        pass

class SpeakerDiarizationFactory(ComponentFactory):
    """è©±è€…åˆ†é›¢ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒª"""

    METHODS = {
        "speechbrain": FreeSpeakerDiarizer,
        "resemblyzer": FreeSpeakerDiarizer,
        "pyannote": SpeakerDiarizer
    }

    def create(self, method: str = "auto", **kwargs):
        if method == "auto":
            # åˆ©ç”¨å¯èƒ½ãªæ–¹æ³•ã‚’è‡ªå‹•é¸æŠ
            if SPEECHBRAIN_AVAILABLE:
                method = "speechbrain"
            elif RESEMBLYZER_AVAILABLE:
                method = "resemblyzer"
            else:
                raise ValueError("No diarization method available")

        diarizer_class = self.METHODS.get(method)
        if not diarizer_class:
            raise ValueError(f"Unknown method: {method}")

        return diarizer_class(method=method, **kwargs)

class LLMCorrectorFactory(ComponentFactory):
    """LLMè£œæ­£ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒª"""

    def create(self, level: str = "simple", **kwargs):
        if level == "simple":
            return SimpleLLMCorrector()
        elif level == "advanced":
            corrector = StandaloneLLMCorrector(**kwargs)
            corrector.load_model()
            return corrector
        elif level == "ollama":
            return LLMCorrector(**kwargs)
        else:
            raise ValueError(f"Unknown level: {level}")
```

**åŠ¹æœ**:
- ä¾å­˜æ€§æ³¨å…¥ã®ä¸€è²«æ€§
- ãƒ†ã‚¹ãƒˆã§ã®ãƒ¢ãƒƒã‚¯åŒ–ãŒå®¹æ˜“
- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®è¿½åŠ ãŒå®¹æ˜“

**æ¨å®šå·¥æ•°**: 3æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 3.4: ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®å‹•çš„åˆ¶å¾¡

**å•é¡Œç‚¹**:
- ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ãŒã‚³ãƒ¼ãƒ‰å†…ã§å›ºå®šï¼ˆ`logging.INFO`ï¼‰
- ãƒ‡ãƒãƒƒã‚°æ™‚ã«ã‚³ãƒ¼ãƒ‰å¤‰æ›´ãŒå¿…è¦

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 33-36)
- å…¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®`if __name__ == "__main__"`ã‚»ã‚¯ã‚·ãƒ§ãƒ³

**è§£æ±ºç­–**:
```python
# src/logging_config.py
import logging
import sys
from pathlib import Path

class LoggingConfigurator:
    """ãƒ­ã‚®ãƒ³ã‚°è¨­å®šã®çµ±ä¸€ç®¡ç†"""

    @staticmethod
    def setup(
        level: str = "INFO",
        log_file: Optional[str] = None,
        format: str = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    ):
        """ãƒ­ã‚®ãƒ³ã‚°ã‚’è¨­å®š"""
        # ãƒ¬ãƒ™ãƒ«ã®è§£æ±º
        numeric_level = getattr(logging, level.upper(), logging.INFO)

        # ãƒãƒ³ãƒ‰ãƒ©ã®è¨­å®š
        handlers = [logging.StreamHandler(sys.stdout)]

        if log_file:
            # ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
            from logging.handlers import RotatingFileHandler
            file_handler = RotatingFileHandler(
                log_file,
                maxBytes=10*1024*1024,  # 10MB
                backupCount=5
            )
            handlers.append(file_handler)

        # ãƒ­ã‚®ãƒ³ã‚°è¨­å®š
        logging.basicConfig(
            level=numeric_level,
            format=format,
            handlers=handlers
        )

        # ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’èª¿æ•´
        logging.getLogger("transformers").setLevel(logging.WARNING)
        logging.getLogger("torch").setLevel(logging.WARNING)
        logging.getLogger("faster_whisper").setLevel(logging.INFO)

    @staticmethod
    def setup_from_env():
        """ç’°å¢ƒå¤‰æ•°ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã¿"""
        level = os.getenv("KOTOBA_LOG_LEVEL", "INFO")
        log_file = os.getenv("KOTOBA_LOG_FILE", None)
        LoggingConfigurator.setup(level=level, log_file=log_file)

# main.pyã§ä½¿ç”¨
if __name__ == "__main__":
    LoggingConfigurator.setup_from_env()
    # ã¾ãŸã¯
    LoggingConfigurator.setup(level="DEBUG", log_file="kotoba.log")
```

**åŠ¹æœ**:
- ãƒ‡ãƒãƒƒã‚°ã®å®¹æ˜“æ€§
- æœ¬ç•ªç’°å¢ƒã§ã®ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
- ç’°å¢ƒå¤‰æ•°ã§ã®åˆ¶å¾¡

**æ¨å®šå·¥æ•°**: 2æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 3.5: Observerãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®çŠ¶æ…‹ç®¡ç†

**å•é¡Œç‚¹**:
- `MainWindow`ã§ã®çŠ¶æ…‹æ›´æ–°ãŒæ•£åœ¨
- çµ±è¨ˆæƒ…å ±ã®æ›´æ–°ãŒè¤‡æ•°ç®‡æ‰€ã§é‡è¤‡

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 1096-1103, 1152-1157)

**è§£æ±ºç­–**: ApplicationStateã‚¯ãƒ©ã‚¹ã§Observerãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ï¼ˆ3.1ã§ææ¡ˆæ¸ˆã¿ï¼‰

**æ¨å®šå·¥æ•°**: 2æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 3.6: Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®æ“ä½œç®¡ç†

**å•é¡Œç‚¹**:
- Undo/Redoæ©Ÿèƒ½ãŒãªã„
- æ“ä½œå±¥æ­´ã®ç®¡ç†ãŒå›°é›£

**è§£æ±ºç­–**:
```python
# src/commands.py
from abc import ABC, abstractmethod

class Command(ABC):
    """ã‚³ãƒãƒ³ãƒ‰ã®åŸºåº•ã‚¯ãƒ©ã‚¹"""

    @abstractmethod
    def execute(self):
        """å®Ÿè¡Œ"""
        pass

    @abstractmethod
    def undo(self):
        """å–ã‚Šæ¶ˆã—"""
        pass

class TranscribeCommand(Command):
    """æ–‡å­—èµ·ã“ã—ã‚³ãƒãƒ³ãƒ‰"""

    def __init__(self, controller, file_path, options):
        self.controller = controller
        self.file_path = file_path
        self.options = options
        self.result = None

    def execute(self):
        self.result = self.controller.transcribe_file(self.file_path, self.options)
        return self.result

    def undo(self):
        # çµæœãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
        output_file = f"{os.path.splitext(self.file_path)[0]}_æ–‡å­—èµ·ã“ã—.txt"
        if os.path.exists(output_file):
            os.remove(output_file)

class CommandManager:
    """ã‚³ãƒãƒ³ãƒ‰å±¥æ­´ã®ç®¡ç†"""

    def __init__(self):
        self.history = []
        self.current_index = -1

    def execute(self, command: Command):
        result = command.execute()
        self.history.append(command)
        self.current_index += 1
        return result

    def undo(self):
        if self.current_index >= 0:
            command = self.history[self.current_index]
            command.undo()
            self.current_index -= 1

    def redo(self):
        if self.current_index < len(self.history) - 1:
            self.current_index += 1
            command = self.history[self.current_index]
            command.execute()
```

**åŠ¹æœ**:
- Undo/Redoæ©Ÿèƒ½ã®å®Ÿè£…
- æ“ä½œå±¥æ­´ã®ç®¡ç†
- ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š

**æ¨å®šå·¥æ•°**: 4æ™‚é–“

---

## 4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–

### ğŸ”´ é«˜å„ªå…ˆåº¦ 4.1: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

**å•é¡Œç‚¹**:
- ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒãã®ã¾ã¾ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹
- ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«æ”»æ’ƒã®ãƒªã‚¹ã‚¯

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 699-715, 717-735)
- `folder_monitor.py` (lines 119-142)

**è§£æ±ºç­–**:
```python
# src/security.py
import os
from pathlib import Path
from typing import Optional

class PathValidator:
    """ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®æ¤œè¨¼ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³"""

    @staticmethod
    def validate_file_path(file_path: str, allowed_dirs: Optional[list] = None) -> str:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ¤œè¨¼ãƒ»æ­£è¦åŒ–

        Args:
            file_path: æ¤œè¨¼ã™ã‚‹ãƒ‘ã‚¹
            allowed_dirs: è¨±å¯ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒªã‚¹ãƒˆ

        Returns:
            æ­£è¦åŒ–ã•ã‚ŒãŸãƒ‘ã‚¹

        Raises:
            ValueError: ä¸æ­£ãªãƒ‘ã‚¹ã®å ´åˆ
        """
        # ãƒ‘ã‚¹ã‚’æ­£è¦åŒ–
        normalized = os.path.normpath(os.path.abspath(file_path))

        # ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«æ¤œå‡º
        if ".." in Path(file_path).parts:
            raise ValueError(f"Path traversal detected: {file_path}")

        # è¨±å¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒã‚§ãƒƒã‚¯
        if allowed_dirs:
            if not any(normalized.startswith(os.path.abspath(d)) for d in allowed_dirs):
                raise ValueError(f"Path not in allowed directories: {file_path}")

        # ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
        if not os.path.exists(normalized):
            raise FileNotFoundError(f"File not found: {file_path}")

        # ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯æ¤œå‡ºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        if os.path.islink(normalized):
            real_path = os.path.realpath(normalized)
            if allowed_dirs and not any(real_path.startswith(os.path.abspath(d)) for d in allowed_dirs):
                raise ValueError(f"Symlink points outside allowed directories: {file_path}")

        return normalized

    @staticmethod
    def validate_output_path(output_path: str, allowed_extensions: set) -> str:
        """å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ¤œè¨¼"""
        normalized = os.path.normpath(os.path.abspath(output_path))

        # æ‹¡å¼µå­ãƒã‚§ãƒƒã‚¯
        ext = os.path.splitext(normalized)[1].lower()
        if ext not in allowed_extensions:
            raise ValueError(f"Invalid output extension: {ext}")

        # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æ›¸ãè¾¼ã¿æ¨©é™ãƒã‚§ãƒƒã‚¯
        output_dir = os.path.dirname(normalized)
        if not os.access(output_dir, os.W_OK):
            raise PermissionError(f"No write permission: {output_dir}")

        return normalized
```

**ä½¿ç”¨ä¾‹**:
```python
def save_text(self):
    """ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜ï¼ˆã‚»ã‚­ãƒ¥ã‚¢ç‰ˆï¼‰"""
    file_path, _ = QFileDialog.getSaveFileName(...)

    if file_path:
        try:
            # ãƒ‘ã‚¹ã‚’æ¤œè¨¼
            validated_path = PathValidator.validate_output_path(
                file_path,
                allowed_extensions={'.txt', '.md'}
            )

            with open(validated_path, 'w', encoding='utf-8') as f:
                f.write(self.result_text.toPlainText())

            logger.info(f"Text saved to: {validated_path}")
        except (ValueError, PermissionError) as e:
            QMessageBox.critical(self, "ã‚¨ãƒ©ãƒ¼", f"ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}")
```

**åŠ¹æœ**:
- ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«æ”»æ’ƒã®é˜²æ­¢
- ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯æ”»æ’ƒã®æ¤œå‡º
- å…¥åŠ›æ¤œè¨¼ã®ä¸€è²«æ€§

**æ¨å®šå·¥æ•°**: 3æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 4.2: APIã‚­ãƒ¼/ãƒˆãƒ¼ã‚¯ãƒ³ã®å®‰å…¨ãªç®¡ç†

**å•é¡Œç‚¹**:
- Hugging Faceãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚³ãƒ¼ãƒ‰å†…ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰å¯èƒ½
- ç’°å¢ƒå¤‰æ•°ã§ã®ç®¡ç†ãŒãªã„

**å½±éŸ¿ç¯„å›²**:
- `speaker_diarization.py` (lines 17-24)

**è§£æ±ºç­–**:
```python
# src/secrets_manager.py
import os
from typing import Optional
from cryptography.fernet import Fernet

class SecretsManager:
    """APIã‚­ãƒ¼ãƒ»ãƒˆãƒ¼ã‚¯ãƒ³ã®å®‰å…¨ãªç®¡ç†"""

    def __init__(self, secrets_file: str = ".secrets"):
        self.secrets_file = secrets_file
        self._key = self._get_or_create_key()
        self._fernet = Fernet(self._key)

    def _get_or_create_key(self) -> bytes:
        """æš—å·åŒ–ã‚­ãƒ¼ã‚’å–å¾—ã¾ãŸã¯ç”Ÿæˆ"""
        key_file = ".key"
        if os.path.exists(key_file):
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            key = Fernet.generate_key()
            with open(key_file, 'wb') as f:
                f.write(key)
            return key

    def get_secret(self, key: str) -> Optional[str]:
        """ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’å–å¾—ï¼ˆç’°å¢ƒå¤‰æ•° â†’ ãƒ•ã‚¡ã‚¤ãƒ« â†’ Noneï¼‰"""
        # 1. ç’°å¢ƒå¤‰æ•°ã‚’ãƒã‚§ãƒƒã‚¯
        env_value = os.getenv(key)
        if env_value:
            return env_value

        # 2. æš—å·åŒ–ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
        if os.path.exists(self.secrets_file):
            with open(self.secrets_file, 'rb') as f:
                encrypted_data = f.read()

            decrypted = self._fernet.decrypt(encrypted_data)
            secrets = dict(line.split('=', 1) for line in decrypted.decode().split('\n') if '=' in line)
            return secrets.get(key)

        return None

    def set_secret(self, key: str, value: str):
        """ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ä¿å­˜"""
        secrets = {}

        if os.path.exists(self.secrets_file):
            with open(self.secrets_file, 'rb') as f:
                encrypted_data = f.read()
            decrypted = self._fernet.decrypt(encrypted_data)
            secrets = dict(line.split('=', 1) for line in decrypted.decode().split('\n') if '=' in line)

        secrets[key] = value

        # æš—å·åŒ–ã—ã¦ä¿å­˜
        data = '\n'.join(f"{k}={v}" for k, v in secrets.items())
        encrypted = self._fernet.encrypt(data.encode())

        with open(self.secrets_file, 'wb') as f:
            f.write(encrypted)

# ä½¿ç”¨ä¾‹
secrets_manager = SecretsManager()
hf_token = secrets_manager.get_secret("HUGGINGFACE_TOKEN")

if not hf_token:
    # GUIã§å…¥åŠ›ã‚’ä¿ƒã™
    hf_token, ok = QInputDialog.getText(
        self, "èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³",
        "Hugging Faceãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:",
        QLineEdit.Password
    )
    if ok and hf_token:
        secrets_manager.set_secret("HUGGINGFACE_TOKEN", hf_token)
```

**.gitignore ã«è¿½åŠ **:
```
.secrets
.key
```

**åŠ¹æœ**:
- APIã‚­ãƒ¼ã®å®‰å…¨ãªä¿ç®¡
- ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã‹ã‚‰ã®é™¤å¤–
- ç’°å¢ƒã”ã¨ã®è¨­å®šåˆ†é›¢

**æ¨å®šå·¥æ•°**: 3æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 4.3: å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®ã‚µã‚¤ã‚ºåˆ¶é™

**å•é¡Œç‚¹**:
- éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºåˆ¶é™ãŒãªã„
- å·¨å¤§ãƒ•ã‚¡ã‚¤ãƒ«ã§DoSæ”»æ’ƒã®å¯èƒ½æ€§

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 552-567)
- `folder_monitor.py` (lines 85-117)

**è§£æ±ºç­–**:
```python
class AudioFileValidator:
    MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024  # 2GB

    @classmethod
    def validate_file_size(cls, file_path: str) -> bool:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’æ¤œè¨¼"""
        size = os.path.getsize(file_path)
        if size > cls.MAX_FILE_SIZE:
            raise ValueError(f"File too large: {size / (1024**3):.2f}GB (max: {cls.MAX_FILE_SIZE / (1024**3):.2f}GB)")
        return True
```

**åŠ¹æœ**:
- ãƒªã‚½ãƒ¼ã‚¹æ¯æ¸‡æ”»æ’ƒã®é˜²æ­¢
- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®‰å®šæ€§å‘ä¸Š

**æ¨å®šå·¥æ•°**: 1æ™‚é–“

---

## 5. æ‹¡å¼µæ€§ã®æ”¹å–„

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 5.1: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å°å…¥

**å•é¡Œç‚¹**:
- æ–°ã—ã„æ–‡å­—èµ·ã“ã—ã‚¨ãƒ³ã‚¸ãƒ³ã‚„å‡¦ç†æ©Ÿèƒ½ã®è¿½åŠ ãŒå›°é›£
- ã‚³ãƒ¼ãƒ‰ã®ä¿®æ­£ãŒå¿…è¦

**è§£æ±ºç­–**:
```python
# src/plugin_system.py
from abc import ABC, abstractmethod
from typing import Dict, Type, List
import importlib
import os

class TranscriptionPlugin(ABC):
    """æ–‡å­—èµ·ã“ã—ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®åŸºåº•ã‚¯ãƒ©ã‚¹"""

    @property
    @abstractmethod
    def name(self) -> str:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å"""
        pass

    @property
    @abstractmethod
    def version(self) -> str:
        """ãƒãƒ¼ã‚¸ãƒ§ãƒ³"""
        pass

    @abstractmethod
    def transcribe(self, audio_path: str, **kwargs) -> Dict:
        """æ–‡å­—èµ·ã“ã—å®Ÿè¡Œ"""
        pass

class PluginManager:
    """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, plugins_dir: str = "plugins"):
        self.plugins_dir = plugins_dir
        self.plugins: Dict[str, TranscriptionPlugin] = {}
        self._discover_plugins()

    def _discover_plugins(self):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’è‡ªå‹•æ¤œå‡º"""
        if not os.path.exists(self.plugins_dir):
            return

        for filename in os.listdir(self.plugins_dir):
            if filename.endswith('.py') and not filename.startswith('_'):
                module_name = filename[:-3]
                try:
                    module = importlib.import_module(f"plugins.{module_name}")

                    # TranscriptionPluginã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ã‚’æ¢ã™
                    for attr_name in dir(module):
                        attr = getattr(module, attr_name)
                        if isinstance(attr, type) and issubclass(attr, TranscriptionPlugin) and attr != TranscriptionPlugin:
                            plugin = attr()
                            self.plugins[plugin.name] = plugin
                            logger.info(f"Loaded plugin: {plugin.name} v{plugin.version}")

                except Exception as e:
                    logger.error(f"Failed to load plugin {module_name}: {e}")

    def get_plugin(self, name: str) -> TranscriptionPlugin:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å–å¾—"""
        return self.plugins.get(name)

    def list_plugins(self) -> List[str]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€è¦§"""
        return list(self.plugins.keys())
```

**ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¾‹**:
```python
# plugins/custom_whisper.py
from src.plugin_system import TranscriptionPlugin

class CustomWhisperPlugin(TranscriptionPlugin):
    @property
    def name(self) -> str:
        return "custom-whisper"

    @property
    def version(self) -> str:
        return "1.0.0"

    def transcribe(self, audio_path: str, **kwargs) -> Dict:
        # ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…
        return {"text": "..."}
```

**åŠ¹æœ**:
- æ‹¡å¼µæ©Ÿèƒ½ã®è¿½åŠ ãŒå®¹æ˜“
- ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚µãƒãƒ¼ãƒˆ
- ã‚³ã‚¢ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ä¸è¦

**æ¨å®šå·¥æ•°**: 6æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 5.2: REST APIã®æä¾›

**å•é¡Œç‚¹**:
- GUIå°‚ç”¨ã§å¤–éƒ¨ã‹ã‚‰ã®åˆ©ç”¨ãŒå›°é›£
- ãƒãƒƒãƒå‡¦ç†ã®è‡ªå‹•åŒ–ãŒé›£ã—ã„

**è§£æ±ºç­–**:
```python
# src/api/rest_api.py
from fastapi import FastAPI, File, UploadFile, HTTPException
from pydantic import BaseModel
from typing import Optional
import uvicorn

app = FastAPI(title="KotobaTranscriber API", version="1.0.0")

class TranscriptionRequest(BaseModel):
    enable_diarization: bool = False
    enable_llm_correction: bool = False
    remove_fillers: bool = True

class TranscriptionResponse(BaseModel):
    text: str
    duration: float
    status: str

@app.post("/api/v1/transcribe", response_model=TranscriptionResponse)
async def transcribe_audio(
    file: UploadFile = File(...),
    options: TranscriptionRequest = TranscriptionRequest()
):
    """éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—"""
    try:
        # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
        import tempfile
        with tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(file.filename)[1]) as tmp:
            tmp.write(await file.read())
            temp_path = tmp.name

        # æ–‡å­—èµ·ã“ã—å®Ÿè¡Œ
        controller = TranscriptionController()
        result = controller.transcribe_file(temp_path, options.dict())

        # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        os.unlink(temp_path)

        return TranscriptionResponse(
            text=result["text"],
            duration=result["duration"],
            status="success"
        )

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/health")
async def health_check():
    """ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"""
    return {"status": "healthy"}

def start_api_server(host: str = "0.0.0.0", port: int = 8000):
    """APIã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•"""
    uvicorn.run(app, host=host, port=port)
```

**ä½¿ç”¨ä¾‹**:
```bash
# APIã‚µãƒ¼ãƒãƒ¼èµ·å‹•
python -m src.api.rest_api

# cURLã§ä½¿ç”¨
curl -X POST "http://localhost:8000/api/v1/transcribe" \
  -F "file=@audio.mp3" \
  -F "options={\"enable_diarization\":true}"
```

**åŠ¹æœ**:
- å¤–éƒ¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã®é€£æº
- ãƒãƒƒãƒå‡¦ç†ã®è‡ªå‹•åŒ–
- CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¸ã®çµ„ã¿è¾¼ã¿

**æ¨å®šå·¥æ•°**: 8æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 5.3: Webhookã«ã‚ˆã‚‹é€šçŸ¥

**å•é¡Œç‚¹**:
- å‡¦ç†å®Œäº†ã®é€šçŸ¥ãŒãƒˆãƒ¬ã‚¤ã‚¢ã‚¤ã‚³ãƒ³ã®ã¿
- å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã¨ã®çµ±åˆãŒå›°é›£

**è§£æ±ºç­–**:
```python
# src/notifications/webhook.py
import requests
from typing import Optional, Dict

class WebhookNotifier:
    """Webhooké€šçŸ¥"""

    def __init__(self, webhook_url: Optional[str] = None):
        self.webhook_url = webhook_url or os.getenv("KOTOBA_WEBHOOK_URL")

    def notify_completion(self, file_path: str, result: Dict):
        """å‡¦ç†å®Œäº†ã‚’é€šçŸ¥"""
        if not self.webhook_url:
            return

        payload = {
            "event": "transcription_completed",
            "file": os.path.basename(file_path),
            "duration": result.get("duration", 0),
            "text_length": len(result.get("text", "")),
            "timestamp": datetime.now().isoformat()
        }

        try:
            response = requests.post(
                self.webhook_url,
                json=payload,
                timeout=5
            )
            response.raise_for_status()
            logger.info(f"Webhook notification sent: {file_path}")
        except Exception as e:
            logger.error(f"Failed to send webhook: {e}")

    def notify_error(self, file_path: str, error: str):
        """ã‚¨ãƒ©ãƒ¼ã‚’é€šçŸ¥"""
        if not self.webhook_url:
            return

        payload = {
            "event": "transcription_failed",
            "file": os.path.basename(file_path),
            "error": error,
            "timestamp": datetime.now().isoformat()
        }

        try:
            requests.post(self.webhook_url, json=payload, timeout=5)
        except Exception as e:
            logger.error(f"Failed to send webhook: {e}")
```

**Slacké€£æºä¾‹**:
```python
# Slackã«é€šçŸ¥
webhook_notifier = WebhookNotifier(
    webhook_url="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
)
webhook_notifier.notify_completion(file_path, result)
```

**åŠ¹æœ**:
- Slack/Discord/Teamsç­‰ã¨ã®é€£æº
- ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã¸ã®çµ±åˆ
- ãƒªãƒ¢ãƒ¼ãƒˆå‡¦ç†ã®ç›£è¦–

**æ¨å®šå·¥æ•°**: 3æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 5.4: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆ

**å•é¡Œç‚¹**:
- å‡¦ç†å±¥æ­´ãŒæ°¸ç¶šåŒ–ã•ã‚Œã¦ã„ãªã„
- æ¤œç´¢æ©Ÿèƒ½ãŒãªã„

**è§£æ±ºç­–**:
```python
# src/database/repository.py
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

Base = declarative_base()

class TranscriptionRecord(Base):
    """æ–‡å­—èµ·ã“ã—å±¥æ­´"""
    __tablename__ = 'transcriptions'

    id = Column(Integer, primary_key=True)
    file_path = Column(String, nullable=False)
    file_size = Column(Integer)
    duration = Column(Float)
    text = Column(Text)
    created_at = Column(DateTime, default=datetime.now)
    status = Column(String)  # success, failed
    error_message = Column(Text)

class TranscriptionRepository:
    """æ–‡å­—èµ·ã“ã—å±¥æ­´ã®ãƒªãƒã‚¸ãƒˆãƒª"""

    def __init__(self, db_url: str = "sqlite:///kotoba.db"):
        self.engine = create_engine(db_url)
        Base.metadata.create_all(self.engine)
        Session = sessionmaker(bind=self.engine)
        self.session = Session()

    def save(self, record: TranscriptionRecord):
        """å±¥æ­´ã‚’ä¿å­˜"""
        self.session.add(record)
        self.session.commit()

    def search(self, query: str):
        """ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢"""
        return self.session.query(TranscriptionRecord).filter(
            TranscriptionRecord.text.like(f"%{query}%")
        ).all()

    def get_recent(self, limit: int = 10):
        """æœ€è¿‘ã®å±¥æ­´ã‚’å–å¾—"""
        return self.session.query(TranscriptionRecord).order_by(
            TranscriptionRecord.created_at.desc()
        ).limit(limit).all()
```

**åŠ¹æœ**:
- å‡¦ç†å±¥æ­´ã®æ°¸ç¶šåŒ–
- å…¨æ–‡æ¤œç´¢æ©Ÿèƒ½
- çµ±è¨ˆæƒ…å ±ã®åˆ†æ

**æ¨å®šå·¥æ•°**: 6æ™‚é–“

---

## 6. ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 6.1: ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºã®æ”¹å–„

**å•é¡Œç‚¹**:
- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ãŒå¤§é›‘æŠŠï¼ˆ20%, 50%, 90%, 100%ï¼‰
- æ®‹ã‚Šæ™‚é–“ã®æ¨å®šãŒãªã„

**å½±éŸ¿ç¯„å›²**:
- `main.py` (lines 241-283) - TranscriptionWorker

**è§£æ±ºç­–**:
```python
class ProgressTracker:
    """é€²æ—è¿½è·¡ã¨ETAè¨ˆç®—"""

    def __init__(self, total_steps: int):
        self.total_steps = total_steps
        self.current_step = 0
        self.start_time = time.time()
        self.step_durations = []

    def update(self, step: int, message: str = "") -> Dict:
        """é€²æ—æ›´æ–°"""
        self.current_step = step
        current_time = time.time()

        # å„ã‚¹ãƒ†ãƒƒãƒ—ã®æ‰€è¦æ™‚é–“ã‚’è¨˜éŒ²
        if len(self.step_durations) < step:
            self.step_durations.append(current_time - self.start_time)

        # é€²æ—ç‡
        progress = int((step / self.total_steps) * 100)

        # ETAè¨ˆç®—ï¼ˆç§»å‹•å¹³å‡ï¼‰
        if self.step_durations:
            avg_duration = sum(self.step_durations) / len(self.step_durations)
            remaining_steps = self.total_steps - step
            eta_seconds = avg_duration * remaining_steps

            eta_str = self._format_eta(eta_seconds)
        else:
            eta_str = "è¨ˆç®—ä¸­..."

        return {
            "progress": progress,
            "message": message,
            "eta": eta_str,
            "elapsed": self._format_elapsed(current_time - self.start_time)
        }

    def _format_eta(self, seconds: float) -> str:
        """ETAæ–‡å­—åˆ—ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        if seconds < 60:
            return f"æ®‹ã‚Š {int(seconds)}ç§’"
        elif seconds < 3600:
            return f"æ®‹ã‚Š {int(seconds/60)}åˆ†"
        else:
            return f"æ®‹ã‚Š {int(seconds/3600)}æ™‚é–“{int((seconds%3600)/60)}åˆ†"

    def _format_elapsed(self, seconds: float) -> str:
        """çµŒéæ™‚é–“ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        if seconds < 60:
            return f"{int(seconds)}ç§’"
        elif seconds < 3600:
            return f"{int(seconds/60)}åˆ†{int(seconds%60)}ç§’"
        else:
            return f"{int(seconds/3600)}æ™‚é–“{int((seconds%3600)/60)}åˆ†"

# TranscriptionWorkerã§ä½¿ç”¨
class TranscriptionWorker(QThread):
    progress_detailed = pyqtSignal(dict)  # è©³ç´°ãªé€²æ—æƒ…å ±

    def run(self):
        tracker = ProgressTracker(total_steps=5)

        self.progress_detailed.emit(tracker.update(1, "ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­..."))
        self.engine.load_model()

        self.progress_detailed.emit(tracker.update(2, "éŸ³å£°èª­ã¿è¾¼ã¿ä¸­..."))
        # ...

        self.progress_detailed.emit(tracker.update(3, "æ–‡å­—èµ·ã“ã—å®Ÿè¡Œä¸­..."))
        result = self.engine.transcribe(self.audio_path)

        # ...
```

**UIè¡¨ç¤ºä¾‹**:
```
[====================================----] 85%
æ–‡å­—èµ·ã“ã—å®Ÿè¡Œä¸­... | çµŒé: 2åˆ†30ç§’ | æ®‹ã‚Š: 30ç§’
```

**åŠ¹æœ**:
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¾…æ©Ÿæ™‚é–“ã¸ã®ä¸å®‰è»½æ¸›
- ã‚ˆã‚Šæ­£ç¢ºãªé€²æ—è¡¨ç¤º
- UXå‘ä¸Š

**æ¨å®šå·¥æ•°**: 4æ™‚é–“

---

### ğŸŸ¢ ä½å„ªå…ˆåº¦ 6.2: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å¯¾å¿œ

**å•é¡Œç‚¹**:
- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®ã¿
- ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—éå¯¾å¿œ

**è§£æ±ºç­–**:
```python
# MainWindowã«è¿½åŠ 
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        # ...
        self.setAcceptDrops(True)

    def dragEnterEvent(self, event):
        """ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚"""
        if event.mimeData().hasUrls():
            # éŸ³å£°/å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
            urls = event.mimeData().urls()
            if all(AudioFileValidator.is_supported(url.toLocalFile()) for url in urls):
                event.acceptProposedAction()

    def dropEvent(self, event):
        """ãƒ‰ãƒ­ãƒƒãƒ—æ™‚"""
        urls = event.mimeData().urls()
        file_paths = [url.toLocalFile() for url in urls]

        if len(file_paths) == 1:
            # å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«
            self.selected_file = file_paths[0]
            filename = os.path.basename(file_paths[0])
            self.file_label.setText(f"ãƒ•ã‚¡ã‚¤ãƒ«: {filename}")
            self.transcribe_button.setEnabled(True)
        else:
            # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆãƒãƒƒãƒå‡¦ç†ï¼‰
            self.batch_files = file_paths
            self.batch_file_list.clear()
            for path in file_paths:
                self.batch_file_list.addItem(os.path.basename(path))
            self.batch_file_list.setVisible(True)
            self.file_label.setText(f"ãƒãƒƒãƒãƒ•ã‚¡ã‚¤ãƒ«: {len(file_paths)}å€‹é¸æŠ")
            self.transcribe_button.setEnabled(True)
```

**åŠ¹æœ**:
- æ“ä½œæ€§ã®å‘ä¸Š
- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã®é«˜é€ŸåŒ–

**æ¨å®šå·¥æ•°**: 2æ™‚é–“

---

## 7. ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®æ‹¡å……

### ğŸ”´ é«˜å„ªå…ˆåº¦ 7.1: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®æ§‹ç¯‰

**å•é¡Œç‚¹**:
- ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„
- è‡ªå‹•ãƒ†ã‚¹ãƒˆãŒãªã„

**è§£æ±ºç­–**:
```python
# tests/test_text_formatter.py
import pytest
from src.text_formatter import TextFormatter

class TestTextFormatter:
    """TextFormatterã®ãƒ†ã‚¹ãƒˆ"""

    @pytest.fixture
    def formatter(self):
        return TextFormatter()

    def test_remove_fillers(self, formatter):
        """ãƒ•ã‚£ãƒ©ãƒ¼èªå‰Šé™¤ã®ãƒ†ã‚¹ãƒˆ"""
        input_text = "ã‚ã®ãƒ¼ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆã§ã™ã­ãˆãƒ¼ã¨ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™"
        expected = "ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆã§ã™ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™"
        result = formatter.remove_fillers(input_text)
        assert result == expected

    def test_add_punctuation(self, formatter):
        """å¥èª­ç‚¹è¿½åŠ ã®ãƒ†ã‚¹ãƒˆ"""
        input_text = "ä»Šæ—¥ã¯æ™´ã‚Œã§ã™æ˜æ—¥ã¯é›¨ã§ã™"
        result = formatter.add_punctuation(input_text)
        assert "ã€‚" in result

    def test_format_paragraphs(self, formatter):
        """æ®µè½æ•´å½¢ã®ãƒ†ã‚¹ãƒˆ"""
        input_text = "æ–‡1ã€‚æ–‡2ã€‚æ–‡3ã€‚æ–‡4ã€‚æ–‡5ã€‚"
        result = formatter.format_paragraphs(input_text, max_sentences_per_paragraph=2)
        assert "\n\n" in result

# tests/test_realtime_audio_capture.py
import pytest
from src.realtime_audio_capture import RealtimeAudioCapture
from src.exceptions import AudioDeviceNotFoundError

class TestRealtimeAudioCapture:
    """RealtimeAudioCaptureã®ãƒ†ã‚¹ãƒˆ"""

    def test_list_devices(self):
        """ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§å–å¾—ã®ãƒ†ã‚¹ãƒˆ"""
        with RealtimeAudioCapture() as capture:
            devices = capture.list_devices()
            assert isinstance(devices, list)
            if devices:
                assert "index" in devices[0]
                assert "name" in devices[0]

    def test_invalid_device_index(self):
        """ç„¡åŠ¹ãªãƒ‡ãƒã‚¤ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒ†ã‚¹ãƒˆ"""
        with pytest.raises(AudioDeviceNotFoundError):
            with RealtimeAudioCapture(device_index=999) as capture:
                capture.start_capture()

    def test_context_manager(self):
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®ãƒ†ã‚¹ãƒˆ"""
        capture = RealtimeAudioCapture()
        with capture:
            assert capture.audio is not None
        # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆçµ‚äº†å¾Œã¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œã‚‹
        assert capture.audio is None

# tests/test_error_handling.py
class TestErrorHandling:
    """ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ†ã‚¹ãƒˆ"""

    def test_model_loading_error(self):
        """ãƒ¢ãƒ‡ãƒ«ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ã®ãƒ†ã‚¹ãƒˆ"""
        from src.exceptions import ModelLoadingError
        from src.faster_whisper_engine import FasterWhisperEngine

        engine = FasterWhisperEngine(model_size="invalid-model")
        with pytest.raises(ModelLoadingError):
            engine.load_model()

    def test_vad_invalid_threshold(self):
        """VADç„¡åŠ¹é–¾å€¤ã®ãƒ†ã‚¹ãƒˆ"""
        from src.exceptions import InvalidVADThresholdError
        from src.simple_vad import SimpleVAD

        with pytest.raises(InvalidVADThresholdError):
            SimpleVAD(threshold=1.5)  # ç¯„å›²å¤–

# tests/conftest.py
import pytest
import tempfile
import os

@pytest.fixture
def temp_audio_file():
    """ãƒ†ã‚¹ãƒˆç”¨ã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ"""
    with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as f:
        # ãƒ€ãƒŸãƒ¼éŸ³å£°ãƒ‡ãƒ¼ã‚¿ï¼ˆç„¡éŸ³ï¼‰
        import wave
        import numpy as np

        with wave.open(f.name, 'wb') as wav:
            wav.setnchannels(1)
            wav.setsampwidth(2)
            wav.setframerate(16000)
            audio_data = np.zeros(16000 * 2, dtype=np.int16)  # 2ç§’ã®ç„¡éŸ³
            wav.writeframes(audio_data.tobytes())

        yield f.name
        os.unlink(f.name)
```

**ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ**:
```bash
# pytest ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pip install pytest pytest-cov pytest-mock

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pytest tests/

# ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ
pytest --cov=src --cov-report=html tests/
```

**åŠ¹æœ**:
- ãƒã‚°ã®æ—©æœŸç™ºè¦‹
- ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®å®‰å…¨æ€§å‘ä¸Š
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŠ¹æœ

**æ¨å®šå·¥æ•°**: 16æ™‚é–“

---

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 7.2: çµ±åˆãƒ†ã‚¹ãƒˆã®è¿½åŠ 

**å•é¡Œç‚¹**:
- ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã®ãƒ†ã‚¹ãƒˆãŒãªã„

**è§£æ±ºç­–**:
```python
# tests/integration/test_transcription_pipeline.py
import pytest
from src.transcription_engine import TranscriptionEngine
from src.text_formatter import TextFormatter

class TestTranscriptionPipeline:
    """æ–‡å­—èµ·ã“ã—ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®çµ±åˆãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.slow
    def test_full_pipeline(self, temp_audio_file):
        """å®Œå…¨ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ãƒ†ã‚¹ãƒˆ"""
        # 1. æ–‡å­—èµ·ã“ã—
        engine = TranscriptionEngine()
        engine.load_model()
        result = engine.transcribe(temp_audio_file)

        # 2. ãƒ†ã‚­ã‚¹ãƒˆæ•´å½¢
        formatter = TextFormatter()
        formatted_text = formatter.format_all(result["text"])

        # 3. æ¤œè¨¼
        assert isinstance(formatted_text, str)
        assert len(formatted_text) >= 0  # ç„¡éŸ³ã§ã‚‚ç©ºæ–‡å­—åˆ—ãŒè¿”ã‚‹
```

**åŠ¹æœ**:
- ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®å‹•ä½œç¢ºèª
- ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å•é¡Œã®æ¤œå‡º

**æ¨å®šå·¥æ•°**: 8æ™‚é–“

---

## 8. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå……å®Ÿ

### ğŸŸ¡ ä¸­å„ªå…ˆåº¦ 8.1: API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®è‡ªå‹•ç”Ÿæˆ

**å•é¡Œç‚¹**:
- APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒä¸è¶³
- é–‹ç™ºè€…å‘ã‘ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒãªã„

**è§£æ±ºç­–**:
```python
# Sphinxã§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆè‡ªå‹•ç”Ÿæˆ
pip install sphinx sphinx-rtd-theme

# docs/conf.py
import os
import sys
sys.path.insert(0, os.path.abspath('../src'))

project = 'KotobaTranscriber'
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.napoleon',
    'sphinx.ext.viewcode',
]

# docs/index.rst
KotobaTranscriber API Documentation
===================================

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   modules/transcription_engine
   modules/text_formatter
   modules/realtime_transcriber

API Reference
-------------

.. automodule:: transcription_engine
   :members:
   :undoc-members:
   :show-inheritance:
```

**ãƒ“ãƒ«ãƒ‰**:
```bash
cd docs
sphinx-build -b html . _build
```

**åŠ¹æœ**:
- é–‹ç™ºè€…å‘ã‘ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- ã‚³ãƒ¼ãƒ‰ã¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®åŒæœŸ

**æ¨å®šå·¥æ•°**: 6æ™‚é–“

---

## å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### ãƒ•ã‚§ãƒ¼ã‚º1: åŸºç›¤å¼·åŒ–ï¼ˆ2é€±é–“ï¼‰

**Week 1:**
- ğŸ”´ 1.1: ãƒ¢ãƒ‡ãƒ«ç®¡ç†ã®å…±é€šåŒ–ï¼ˆ4hï¼‰
- ğŸ”´ 2.1: ãƒãƒƒãƒå‡¦ç†ã®ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–ï¼ˆ4hï¼‰
- ğŸ”´ 3.1: MainWindowã®è²¬ä»»åˆ†é›¢ï¼ˆ8hï¼‰
- ğŸ”´ 3.2: è¨­å®šç®¡ç†ã®çµ±ä¸€ï¼ˆ4hï¼‰

**Week 2:**
- ğŸ”´ 2.2: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—ã®ãƒãƒƒãƒ•ã‚¡æœ€é©åŒ–ï¼ˆ3hï¼‰
- ğŸ”´ 4.1: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ3hï¼‰
- ğŸ”´ 7.1: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®æ§‹ç¯‰ï¼ˆ16hï¼‰

**åŠ¹æœ**:
- ã‚³ãƒ¼ãƒ‰å“è³ª: 9.0 â†’ 9.3
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 0% â†’ 40%
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: -50%

---

### ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼ˆ1é€±é–“ï¼‰

**Week 3:**
- ğŸŸ¡ 1.2: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ±ä¸€ï¼ˆ3hï¼‰
- ğŸŸ¡ 1.3: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã®çµ±ä¸€åŸºåº•ã‚¯ãƒ©ã‚¹ï¼ˆ2hï¼‰
- ğŸŸ¡ 2.3: è©±è€…åˆ†é›¢ã®ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ï¼ˆ2hï¼‰
- ğŸŸ¡ 2.4: VADã®è¨ˆç®—é‡å‰Šæ¸›ï¼ˆ2hï¼‰
- ğŸŸ¡ 3.3: ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ‹¡å¼µï¼ˆ3hï¼‰
- ğŸŸ¡ 3.4: ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®å‹•çš„åˆ¶å¾¡ï¼ˆ2hï¼‰

**åŠ¹æœ**:
- ã‚³ãƒ¼ãƒ‰å“è³ª: 9.3 â†’ 9.5
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹: +30%

---

### ãƒ•ã‚§ãƒ¼ã‚º3: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»æ‹¡å¼µæ€§ï¼ˆ1é€±é–“ï¼‰

**Week 4:**
- ğŸŸ¡ 4.2: APIã‚­ãƒ¼/ãƒˆãƒ¼ã‚¯ãƒ³ã®å®‰å…¨ãªç®¡ç†ï¼ˆ3hï¼‰
- ğŸŸ¡ 5.1: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å°å…¥ï¼ˆ6hï¼‰
- ğŸŸ¡ 5.2: REST APIã®æä¾›ï¼ˆ8hï¼‰
- ğŸŸ¡ 6.1: ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºã®æ”¹å–„ï¼ˆ4hï¼‰
- ğŸŸ¡ 7.2: çµ±åˆãƒ†ã‚¹ãƒˆã®è¿½åŠ ï¼ˆ8hï¼‰

**åŠ¹æœ**:
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: +60%
- ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 40% â†’ 65%
- æ‹¡å¼µæ€§: +100%

---

### ãƒ•ã‚§ãƒ¼ã‚º4: UXãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆï¼ˆ3æ—¥ï¼‰

**Week 5 (Part 1):**
- ğŸŸ¢ 1.4: ãƒ†ã‚­ã‚¹ãƒˆæ•´å½¢ãƒ­ã‚¸ãƒƒã‚¯ã®å…±é€šåŒ–ï¼ˆ3hï¼‰
- ğŸŸ¢ 1.5: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¤œè¨¼ã®å…±é€šåŒ–ï¼ˆ1hï¼‰
- ğŸŸ¢ 4.3: å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®ã‚µã‚¤ã‚ºåˆ¶é™ï¼ˆ1hï¼‰
- ğŸŸ¢ 5.3: Webhookã«ã‚ˆã‚‹é€šçŸ¥ï¼ˆ3hï¼‰
- ğŸŸ¢ 5.4: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆï¼ˆ6hï¼‰
- ğŸŸ¢ 6.2: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å¯¾å¿œï¼ˆ2hï¼‰
- ğŸŸ¡ 8.1: API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®è‡ªå‹•ç”Ÿæˆï¼ˆ6hï¼‰

**åŠ¹æœ**:
- ã‚³ãƒ¼ãƒ‰å“è³ª: 9.5 â†’ 9.7
- UX: +40%
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: +200%

---

## æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ

### ã‚³ãƒ¼ãƒ‰å“è³ª
- **Before**: 9.0/10
- **After**: 9.7/10
- **æ”¹å–„**: +7.8%

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡**: -50%ï¼ˆãƒãƒƒãƒå‡¦ç†æ™‚ï¼‰
- **ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·**: -50%ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ™‚ï¼‰
- **å‡¦ç†é€Ÿåº¦**: +30%ï¼ˆVADæœ€é©åŒ–ï¼‰

### ä¿å®ˆæ€§
- **ã‚³ãƒ¼ãƒ‰è¡Œæ•°**: -800è¡Œï¼ˆé‡è¤‡å‰Šé™¤ï¼‰
- **ã‚¯ãƒ©ã‚¹ã®å¹³å‡è¡Œæ•°**: 600è¡Œ â†’ 250è¡Œ
- **å¾ªç’°çš„è¤‡é›‘åº¦**: -20%

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- **è„†å¼±æ€§**: ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«ã€DoSå¯¾ç­–
- **ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°**: +60%

### ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£
- **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸**: 0% â†’ 65%
- **ãƒ†ã‚¹ãƒˆæ•°**: 0 â†’ 80+

### æ‹¡å¼µæ€§
- **ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚µãƒãƒ¼ãƒˆ**: æœ‰åŠ¹åŒ–
- **REST API**: æä¾›é–‹å§‹
- **Webhookçµ±åˆ**: å¯¾å¿œ

### ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£
- **é€²æ—è¡¨ç¤ºç²¾åº¦**: +300%ï¼ˆETAè¿½åŠ ï¼‰
- **æ“ä½œæ€§**: +40%ï¼ˆD&Då¯¾å¿œï¼‰

---

## ç·æ¨å®šå·¥æ•°

| ãƒ•ã‚§ãƒ¼ã‚º | æœŸé–“ | å·¥æ•° | å„ªå…ˆåº¦ |
|---------|-----|------|--------|
| ãƒ•ã‚§ãƒ¼ã‚º1: åŸºç›¤å¼·åŒ– | 2é€±é–“ | 42æ™‚é–“ | ğŸ”´ é«˜ |
| ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ | 1é€±é–“ | 14æ™‚é–“ | ğŸŸ¡ ä¸­ |
| ãƒ•ã‚§ãƒ¼ã‚º3: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»æ‹¡å¼µæ€§ | 1é€±é–“ | 29æ™‚é–“ | ğŸŸ¡ ä¸­ |
| ãƒ•ã‚§ãƒ¼ã‚º4: UXãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ | 3æ—¥ | 22æ™‚é–“ | ğŸŸ¢ ä½ |
| **åˆè¨ˆ** | **4.6é€±é–“** | **107æ™‚é–“** | - |

**1æ—¥6æ™‚é–“ä½œæ¥­ã¨ã—ã¦: ç´„18æ—¥ï¼ˆç´„4.5é€±é–“ï¼‰**

---

## æ¨å¥¨å®Ÿè£…é †åº

### å³åº§ã«å®Ÿæ–½ã™ã¹ãï¼ˆWeek 1-2ï¼‰
1. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®æ§‹ç¯‰ï¼ˆ7.1ï¼‰ - å“è³ªä¿è¨¼ã®åŸºç›¤
2. ãƒ¢ãƒ‡ãƒ«ç®¡ç†ã®å…±é€šåŒ–ï¼ˆ1.1ï¼‰ - ã‚³ãƒ¼ãƒ‰é‡è¤‡ã®æœ€å¤§è¦å› 
3. ãƒãƒƒãƒå‡¦ç†ã®ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–ï¼ˆ2.1ï¼‰ - OOMå•é¡Œã®è§£æ±º
4. MainWindowã®è²¬ä»»åˆ†é›¢ï¼ˆ3.1ï¼‰ - ä¿å®ˆæ€§ã®å¤§å¹…å‘ä¸Š

### æ—©æœŸã«å®Ÿæ–½ã™ã¹ãï¼ˆWeek 3-4ï¼‰
5. è¨­å®šç®¡ç†ã®çµ±ä¸€ï¼ˆ3.2ï¼‰ - ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã®æŸ”è»Ÿæ€§
6. ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ4.1ï¼‰ - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¿…é ˆ
7. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ±ä¸€ï¼ˆ1.2ï¼‰ - å®‰å®šæ€§å‘ä¸Š
8. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å°å…¥ï¼ˆ5.1ï¼‰ - å°†æ¥ã®æ‹¡å¼µæ€§

### ä¸­æœŸçš„ã«å®Ÿæ–½ï¼ˆWeek 5ä»¥é™ï¼‰
9. REST APIã®æä¾›ï¼ˆ5.2ï¼‰ - å¤–éƒ¨é€£æº
10. çµ±åˆãƒ†ã‚¹ãƒˆã®è¿½åŠ ï¼ˆ7.2ï¼‰ - E2Eãƒ†ã‚¹ãƒˆ
11. APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®è‡ªå‹•ç”Ÿæˆï¼ˆ8.1ï¼‰ - é–‹ç™ºè€…å‘ã‘

---

## ãƒªã‚¹ã‚¯ç®¡ç†

### æŠ€è¡“çš„ãƒªã‚¹ã‚¯
1. **ãƒ¢ãƒ‡ãƒ«ç®¡ç†ã®å…±é€šåŒ–ï¼ˆ1.1ï¼‰**: å„ã‚¨ãƒ³ã‚¸ãƒ³ã®ç‰¹æ€§ã«ã‚ˆã‚Šå®Œå…¨ãªçµ±ä¸€ãŒå›°é›£
   - **å¯¾ç­–**: æŠ½è±¡åº¦ã®é«˜ã„åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’è¨­è¨ˆã—ã€å€‹åˆ¥ã®å·®ç•°ã¯å„ã‚¯ãƒ©ã‚¹ã§å¸å

2. **MainWindowã®è²¬ä»»åˆ†é›¢ï¼ˆ3.1ï¼‰**: å¤§è¦æ¨¡ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã«ã‚ˆã‚‹æ—¢å­˜æ©Ÿèƒ½ã®ç ´å£Š
   - **å¯¾ç­–**: æ®µéšçš„ãªåˆ†å‰²ã€åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã®å…ˆè¡Œå®Ÿæ–½

3. **REST APIã®æä¾›ï¼ˆ5.2ï¼‰**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãƒãƒ©ãƒ³ã‚¹
   - **å¯¾ç­–**: èªè¨¼ãƒ»ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®å®Ÿè£…ã€éåŒæœŸå‡¦ç†ã®æ´»ç”¨

### ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒªã‚¹ã‚¯
1. **ãƒ†ã‚¹ãƒˆæ§‹ç¯‰ï¼ˆ7.1ï¼‰**: æƒ³å®šã‚ˆã‚Šæ™‚é–“ãŒã‹ã‹ã‚‹å¯èƒ½æ€§
   - **å¯¾ç­–**: ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ‘ã‚¹å„ªå…ˆã€æ®µéšçš„ãªå®Ÿè£…

---

## çµè«–

KotobaTranscriberã¯æ—¢ã«é«˜å“è³ªãªã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ï¼ˆ9.0/10ï¼‰ã‚’æŒã£ã¦ã„ã¾ã™ãŒã€æœ¬ææ¡ˆã®å®Ÿè£…ã«ã‚ˆã‚Š**9.7/10ã¾ã§å‘ä¸Š**ã—ã€ä»¥ä¸‹ã®é ˜åŸŸã§å¤§å¹…ãªæ”¹å–„ãŒæœŸå¾…ã§ãã¾ã™:

- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡50%å‰Šæ¸›ã€ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·50%æ”¹å–„
- **ä¿å®ˆæ€§**: ã‚³ãƒ¼ãƒ‰é‡è¤‡800è¡Œå‰Šæ¸›ã€ã‚¯ãƒ©ã‚¹ã‚µã‚¤ã‚º60%ç¸®å°
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«ãƒ»DoSå¯¾ç­–ã®å®Ÿè£…
- **ãƒ†ã‚¹ãƒˆ**: ã‚«ãƒãƒ¬ãƒƒã‚¸0% â†’ 65%
- **æ‹¡å¼µæ€§**: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã€REST APIå°å…¥

**æ¨å¥¨ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**: ãƒ•ã‚§ãƒ¼ã‚º1ï¼ˆåŸºç›¤å¼·åŒ–ï¼‰ã‹ã‚‰é †æ¬¡å®Ÿè£…ã—ã€å„ãƒ•ã‚§ãƒ¼ã‚ºã§åŠ¹æœã‚’æ¸¬å®šã—ãªãŒã‚‰é€²ã‚ã‚‹ã“ã¨ã§ã€ä½ãƒªã‚¹ã‚¯ã§é«˜ã„åŠ¹æœã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚

---

**ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆæ—¥**: 2025-10-16
**ä½œæˆè€…**: Code Analyzer Agent
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0.0
